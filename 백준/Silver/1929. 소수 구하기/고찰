초안은 다음과 같았다.
----------------------------
a, b = map(int, input().split())
for i in range(a,b+1):
    for j in range(2,(i//2)+1):
        if (i%j)==0: break
        if j==(i//2): print(i)
-----------------------------
1. 계산 범위에 대한 문제
- 합성수에서 쌍을 이루는 약수에 대해 필연적으로 (i//2)보다 큰 수 하나, 작은 수 하나가 생기므로 i까지 모든 자연수가 아닌 반만 연산하면 된다고 생각했다.
- 그러나 하나의 약수는 i**0.5보다 작으므로, 해당 수까지만 계산하면 된. 이 차이는 숫자가 커질수록 극명해진다.

2. 조건 범위에 대한 문제
- 2,3의 경우 for j in range(2,(i//2)+1):에서 빈 범위가 되버린다.
- 보통 플래그를 사용한다.

3. 출력문에 대한 문제
- 모든 for문에 조건을 만족할 때 마다 일일히 print를 사용하는 것은 비교적 느리다.
- 조건을 만족하는 수들을 배열에 추가한 다음 이를 출력하는 것이 권장된다.

위와 같은 문제를 보완하면 다음과 같다.
-----------------------------
a, b = map(int, input().split())
prime_num = []
for i in range(a, b+1):
    condition = True
    if i == 1 : continue
    for j in range(2, int(i**0.5) + 1):
        if i % j == 0:
            condition = False
            break
    if condition:
        prime_num.append(i)
print(*prime_num, sep='\n')
-----------------------------
